
.. _reproduce_shalek2013:

.. currentmodule:: flotilla

Accurate estimation of alternative splicing modalities
======================================================

As shown in previous work (`Shalek+Satija et al 2013 <http://www.ncbi.nlm.nih.gov/pubmed/23685454>`_), the majority of alternative splicing in single cells is all or nothing - either the included isoform or the excluded isoform. Rarely are there genes whose included/excluded isoforms are held at a 50/50 ratio. However, it is unclear what fraction of transcripts are maintained at specific proportions across cells, and we aim to categorize these splicing events into five bins: included, middle, excluded, bimodal, and uniform.

First, let's import the modules we'll need.

.. code:: python

    %matplotlib inline
    
    import os
    
    import matplotlib.pyplot as plt
    import numpy as np
    import pandas as pd
    import seaborn as sns
    sns.set(context='notebook', style='ticks')
    
    from flotilla.compute.splicing import ModalityEstimator, ModalityModel
    from flotilla.visualize.splicing import ModalitiesViz


.. parsed-literal::

    :0: FutureWarning: IPython widgets are experimental and may change in the future.


Next, we will initialize a ``ModalityEstimator`` for performing the
calculations, and a ``ModalityViz`` for visualizing the results.

.. code:: python

    modality_estimator = ModalityEstimator(step=1, vmax=10)
    modality_visualizer = ModalitiesViz()

Next, let's plot the modalities we are modeling as `violin plots <http://en.wikipedia.org/wiki/Violin_plot>`_. We model splicing events' "percent spliced-in" or Psi/$\Psi$ as following a `Beta distribution <http://en.wikipedia.org/wiki/Beta_distribution>`_:

$$
\begin{align}
\Psi &\sim \text{Beta}\left(\alpha, \beta\right)\\
&= \frac{1}{B(\alpha, \beta)} x^{\alpha-1}(1-x)^{\beta-1}
\end{align}
$$

Where $B(\alpha, \beta)$ is the [Beta *function*](http://en.wikipedia.org/wiki/Beta_function), from which the Beta *distribution* gets its name,

$$
B\left(\alpha, \beta\right) = \int_0^1 t^{\alpha-1}(1-t)^{\beta-1}dt
$$

The Beta distribution is perfect for splicing scores because ...

1. It is continuous between 0 and 1, so any and all new splicing events we encounter are always valid by the model
2. Its parameters, $\alpha$ and $\beta$ can be tuned to create the characteristic modalities we are interested in

Specifically, we can model the *included*, *middle*, *excluded*, or *bimodal* modalities. In the plot below, note that only the first four are actually in the model, and that the uniform distribution was separately created. This is because the uniform distribution cannot be parameterized, it is exactly when $\alpha=1$ and $\beta=1$, and as every splicing event has exactly the same probability under the uniform distribution, $Pr_{\text{Uniform}}(\text{event})=1$, we will use the uniform distribution as our null model for testing.

.. code:: python

    fig, ax = plt.subplots(figsize=(2*5, 4))
    
    n = 10000
    
    # Use the last parameterization (we'll get to that next) in the model list of random variables "rvs"
    model_data = pd.DataFrame({model_name: model.rvs[-1].rvs(n) for model_name, model in modality_estimator.models.items()})
    model_params = pd.Series({model_name: model.rvs[-1].args for model_name, model in modality_estimator.models.items()})
    
    # Add the uniform distribution
    model_data['uniform'] = np.linspace(0, 1, num=n)
    
    # Reorder the columns
    columns_ordered = ['included', 'middle', 'bimodal', 'excluded', 'uniform']
    model_data = model_data.reindex(columns=columns_ordered)
    
    # Get modality colors
    colors = [modality_visualizer.modality_colors[m] for m in model_data.columns]
    
    # Rename the columns to include the alpha and beta parameters
    modality_with_params_renamer = {model_name: '{}\n$\\alpha={:.2f}$\n$\\beta={:.2f}$'.format(model_name, alpha, beta) 
     for model_name, (alpha, beta) in model_params.iteritems()}
    modality_with_params_renamer['uniform'] = 'uniform\n$\\alpha=1$\n$\\beta=1$'
    model_data = model_data.rename(columns=modality_with_params_renamer)
    
    sns.violinplot(model_data, bw=0.2, color=colors)
    ax.set_ylim(0, 1)
    ax.set_ylabel('$\Psi$')
    ax.set_yticks([0, 0.5, 1])
    sns.despine()
    fig.tight_layout()


.. parsed-literal::

    /home/travis/miniconda/envs/testenv/lib/python2.7/site-packages/matplotlib/font_manager.py:1282: UserWarning: findfont: Font family [u'Helvetica', u'Arial'] not found. Falling back to Bitstream Vera Sans
      (prop.get_family(), self.defaultFamily[fontext]))



.. image:: modalities_files/modalities_7_1.png


Parameterizations of Bayesian model
-----------------------------------

We will employ a Bayesian model to do a (very non-exhaustive) "grid search" of parameter space for splicing events. Meaning, given a particular splicing event, does it match one of these modalities' parameterizations?

.. code:: python

    ncols = len(modality_estimator.models['included'].alphas)
    nrows = len(modality_estimator.models)
    
    fig, axes = plt.subplots(nrows=nrows, ncols=1, figsize=(2*ncols, 4*nrows))
    
    n = 10000
    
    for ax, (model_name, model) in zip(axes, modality_estimator.models.items()):
        parameterizations = [rv.rvs(n) for rv in model.rvs]
        color = modality_visualizer.modality_colors[model_name]
        xticklabels = ['$\\alpha={:.3f}$\n$\\beta={:.3f}$'.format(a, b) for a, b in zip(model.alphas, model.betas)]
        sns.violinplot(parameterizations, bw=0.2, color=color, names=xticklabels, #color=colors, 
                       ax=ax)
        ax.set_ylim(0, 1)
        ax.set_ylabel('$\Psi$')
        ax.set_yticks([0, 0.5, 1])
        ax.set_title(model_name)
    fig.tight_layout()
    sns.despine()



.. image:: modalities_files/modalities_10_0.png


Prior probability on parameterizations
--------------------------------------

We use a uniform prior on all parameterizations except the *bimodal*
distribution. This is because through extensive testing, we have found
that using a uniform prior on the *bimodal* distribution causes slightly
noisy (+10% uniform noise) *included* and *excluded* splicing events to
be called "bimodal," and we want to eliminate false postives in the
*bimodal* category.

.. code:: python

    fig, axes = plt.subplots(nrows=nrows, ncols=1, figsize=(2*ncols, 4*nrows), sharey=True)
    
    n = 10000
    
    n_params = 10
    
    for ax, (model_name, model) in zip(axes, modality_estimator.models.items()):
        color = modality_visualizer.modality_colors[model_name]
        if model_name == 'bimodal':
            ymax = np.exp(np.arange(len(modality_estimator.parameters))).astype(float)
            ymax = ymax/ymax.sum()
        else:
            ymax = np.ones(len(modality_estimator.parameters)).astype(float)/len(modality_estimator.parameters)
        ymin = np.zeros(ymax.shape)
        x = np.arange(ymax.shape[0])
        ax.plot(x, ymax, 'o-', color=color, linewidth=5, markersize=20)
        ax.fill_between(x, ymin, ymax, color=color, alpha=0.75)
        ax.set_xlim(0, x.max())
        xticklabels = ['$\\alpha={:.3f}$\n$\\beta={:.3f}$'.format(a, b) for a, b in zip(model.alphas, model.betas)]
        ax.set_xticks(x)
    
        ax.set_ylabel('Prior probability')
    
        ax.set_xticklabels(xticklabels)
        ax.set_xlim(x.min()-0.5, x.max()+0.5)
        ax.set_title(model_name)
        
    fig.tight_layout()
    sns.despine()



.. image:: modalities_files/modalities_13_0.png


Testing modality estimation
---------------------------

To show that this framework is accurate, we start with a "perfect" event, which uses the last parameterization of each model, which is the "most extreme" version of that model under our assumptions.

.. code:: python

    n = 100
    event = pd.Series(modality_estimator.inclusion_model.rvs[-1].rvs(n))
    
    
    sns.set(style='ticks')
    fig, ax = plt.subplots(figsize=(2, 4))
    sns.violinplot(event, ax=ax, bw=0.2, color=modality_visualizer.modality_colors['included'])
    ax.set_ylim(0, 1)
    ax.set_yticks([0, 0.5, 1])
    sns.despine()
    fig.tight_layout()



.. image:: modalities_files/modalities_16_0.png


Let's estimate the modality of this event by calculating the log-likelihood of each parameterization using ``modality_estimator._loglik``, and summing the results using ``modality_estimator._logsumexp``.

.. code:: python

    logliks = modality_estimator._loglik(event)
    logsumexps = modality_estimator._logsumexp(logliks)
    
    # Visualize the events
    plotter = modality_visualizer.event_estimation(event, logliks, logsumexps)



.. image:: modalities_files/modalities_18_0.png


The left panel shows a violinplot of the event. The middle panel shows the log-likelihoods of different models at increasing parameterizations. The right panel shows the total summed `Bayes factors <http://en.wikipedia.org/wiki/Bayes_factor>`_ of how much more likely a model is over the uniform distribution, where the cutoff for a guessing that something is a uniform distribution is a $\log_2\left(\text{Bayes factor}\right) > 3$.

Let's add add random noise to the "perfect" included event, and see how that changes the modality estimation.

.. code:: python

    sns.set(style='ticks')
    fig, ax = plt.subplots(figsize=(2, 4))
    event_noisy = event.copy()
    event_noisy[:50] = np.random.uniform(size=50)
    
    sns.violinplot(event_noisy, ax=ax, bw=0.2, color=modality_visualizer.modality_colors['included'])
    ax.set_ylim(0, 1)
    ax.set_yticks([0, 0.5, 1])
    
    sns.despine()
    fig.tight_layout()



.. image:: modalities_files/modalities_20_0.png


.. code:: python

    logliks = modality_estimator._loglik(event_noisy)
    logsumexps = modality_estimator._logsumexp(logliks)
    
    # Visualize the events
    plotter = modality_visualizer.event_estimation(event_noisy, logliks, logsumexps)



.. image:: modalities_files/modalities_21_0.png


The included modality becomes less likely, but it still beats out the uniform and bimodal distributions, which is what we want.

Let's use this idea of noise to estimate modalities. We'll use 100 cells total, and do 3 iterations of adding noise at 0%, 25%, and 50%. We will visualize each estimation using the same ``modality_visualizer`` for the parameterizations. This will output quite a few plots.

.. code:: python

    # We will be writing incrementally to this "modality_guesses" file, because if
    # this is done with many iterations and many noise levels, the file gets too
    # big and the IPython kernel crashes
    modality_guesses_csv = 'modality_guesses.csv'
    
    # ALways start fresh with a new csv file
    try:
        os.remove(modality_guesses_csv)
    except OSError:
        pass
    
    n_cells = 100
    n_cell = n_cells
    n_noisys = (0, 25, 50)
    
    columns = ['prior', 'true_modality', 'guessed_modality', 'n_rogue', 'iteration']
    
    df = pd.DataFrame(columns=columns)
    df.to_csv(modality_guesses_csv, index=False)
    
    for n_noisy in n_noisys:
        for i in range(5):
            rows = []
            for model_name, model in modality_estimator.models.items():
                rv = model.rvs[-1]
                event = pd.Series(rv.rvs(n_cells))
                event.name = 'True modality: {}'.format(model_name)
    
                event[:n_noisy] = np.random.uniform(size=n_noisy)
                
                n = len(modality_estimator.bimodal_model.prob_parameters)
    
                logliks = modality_estimator._loglik(event)
                logsumexps = modality_estimator._logsumexp(logliks)
                
                # Visualize the events
                plotter = modality_visualizer.event_estimation(event, logliks, logsumexps)
                filename = '{}_nnoisy{}_iter{}_bimodal_exponential_other_uniform_prior.pdf'.format(model_name, n_cell, n_noisy, i)
                plotter.fig.savefig(filename)
                rows.append(['bimodal_exponential_other_uniform', model_name, logsumexps.argmax(), n_noisy, i])
    
            modality_guesses = pd.DataFrame(rows, columns=columns)
            with open(modality_guesses_csv, 'a') as f:
                modality_guesses.to_csv(f, header=False, index=False)


.. parsed-literal::

    /home/travis/miniconda/envs/testenv/lib/python2.7/site-packages/matplotlib/pyplot.py:424: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max_open_warning`).
      max_open_warning, RuntimeWarning)



.. image:: modalities_files/modalities_23_1.png



.. image:: modalities_files/modalities_23_2.png



.. image:: modalities_files/modalities_23_3.png



.. image:: modalities_files/modalities_23_4.png



.. image:: modalities_files/modalities_23_5.png



.. image:: modalities_files/modalities_23_6.png



.. image:: modalities_files/modalities_23_7.png



.. image:: modalities_files/modalities_23_8.png



.. image:: modalities_files/modalities_23_9.png



.. image:: modalities_files/modalities_23_10.png



.. image:: modalities_files/modalities_23_11.png



.. image:: modalities_files/modalities_23_12.png



.. image:: modalities_files/modalities_23_13.png



.. image:: modalities_files/modalities_23_14.png



.. image:: modalities_files/modalities_23_15.png



.. image:: modalities_files/modalities_23_16.png



.. image:: modalities_files/modalities_23_17.png



.. image:: modalities_files/modalities_23_18.png



.. image:: modalities_files/modalities_23_19.png



.. image:: modalities_files/modalities_23_20.png



.. image:: modalities_files/modalities_23_21.png



.. image:: modalities_files/modalities_23_22.png



.. image:: modalities_files/modalities_23_23.png



.. image:: modalities_files/modalities_23_24.png



.. image:: modalities_files/modalities_23_25.png



.. image:: modalities_files/modalities_23_26.png



.. image:: modalities_files/modalities_23_27.png



.. image:: modalities_files/modalities_23_28.png



.. image:: modalities_files/modalities_23_29.png



.. image:: modalities_files/modalities_23_30.png



.. image:: modalities_files/modalities_23_31.png



.. image:: modalities_files/modalities_23_32.png



.. image:: modalities_files/modalities_23_33.png



.. image:: modalities_files/modalities_23_34.png



.. image:: modalities_files/modalities_23_35.png



.. image:: modalities_files/modalities_23_36.png



.. image:: modalities_files/modalities_23_37.png



.. image:: modalities_files/modalities_23_38.png



.. image:: modalities_files/modalities_23_39.png



.. image:: modalities_files/modalities_23_40.png



.. image:: modalities_files/modalities_23_41.png



.. image:: modalities_files/modalities_23_42.png



.. image:: modalities_files/modalities_23_43.png



.. image:: modalities_files/modalities_23_44.png



.. image:: modalities_files/modalities_23_45.png



.. image:: modalities_files/modalities_23_46.png



.. image:: modalities_files/modalities_23_47.png



.. image:: modalities_files/modalities_23_48.png



.. image:: modalities_files/modalities_23_49.png



.. image:: modalities_files/modalities_23_50.png



.. image:: modalities_files/modalities_23_51.png



.. image:: modalities_files/modalities_23_52.png



.. image:: modalities_files/modalities_23_53.png



.. image:: modalities_files/modalities_23_54.png



.. image:: modalities_files/modalities_23_55.png



.. image:: modalities_files/modalities_23_56.png



.. image:: modalities_files/modalities_23_57.png



.. image:: modalities_files/modalities_23_58.png



.. image:: modalities_files/modalities_23_59.png



.. image:: modalities_files/modalities_23_60.png


Now let's plot the accuracy of the model on the increasingly noisy splicing events and their modality estimations.

.. code:: python

    modality_guesses = pd.read_csv(modality_guesses_csv)
    
    model_accuracy = modality_guesses.groupby(['prior', 'n_rogue', 
                                               'true_modality']).apply(lambda x: (x.true_modality == x.guessed_modality).sum())/n_noisys.max()*n_cells
    model_accuracy = model_accuracy.reset_index()
    model_accuracy = model_accuracy.rename(columns={0: 'percentage'})
    fg = sns.factorplot('n_rogue', col='prior', data=model_accuracy, y='percentage', hue='true_modality',
                   hue_order=('excluded', 'middle', 'included', 'bimodal'), palette='deep', kind='point')
    fg.fig.savefig('percent_noise_vs_true_positives.pdf')
    
    
    false_positives = modality_guesses.groupby(['prior', 'n_rogue', 
                                                'guessed_modality', 'true_modality']).apply(lambda x: (x.true_modality != x.guessed_modality).sum())/50
    # false_positives = false_positives.unstack()
    false_positives = false_positives.reset_index()
    false_positives = false_positives.rename(columns={0: 'counts'})
    false_positives.head()
    
    fg = sns.factorplot('n_rogue', y='counts', row='prior', col='true_modality', hue='guessed_modality', data=false_positives,
                   hue_order=('excluded', 'middle', 'included', 'bimodal', 'uniform'), palette='deep', size=6)
    fg.fig.savefig('percent_noise_vs_false_positives_factorplot.pdf')


::


    ---------------------------------------------------------------------------

    AttributeError                            Traceback (most recent call last)

    <ipython-input-11-47af08ce33bf> in <module>()
          2 
          3 model_accuracy = modality_guesses.groupby(['prior', 'n_rogue', 
    ----> 4                                            'true_modality']).apply(lambda x: (x.true_modality == x.guessed_modality).sum())/n_noisys.max()*n_cells
          5 model_accuracy = model_accuracy.reset_index()
          6 model_accuracy = model_accuracy.rename(columns={0: 'percentage'})


    AttributeError: 'tuple' object has no attribute 'max'


The "middle" modalities become less accurate at about 30% noise, but from looking at the events, I'm happy with these getting "mis-categorized" because they do truly look like "uniform" events.
